<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>bs - programming language </title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Bs</h1>
        <h2><em>bs</em> is a programming language designed to be concise and simple </h2>

        <section id="downloads">
          <a href="https://github.com/isakkarlsson/bs/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/isakkarlsson/bs/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/isakkarlsson/bs" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>Introduction</h3>
	<h4>Overview</h4>
	<p>
	  <em>bs</em> ('bullshit' or 'bullstund') is a prototype based
	  programming language inspired
	  by <em>io</em>, <em>smalltalk</em> and to some
	  degree <em>Javascript</em>. Everything is an object and every
	  modification is done by a method invocation. There are, only
	  one deviation from that rule; assignment.
	</p>

        <h4>Goals</h4>
	<p>
	  The goal of <em>bs</em> are to be;
	  <ul>
	    <li>Consistent</li>
	    <li>Expressive</li>
	    <li>(relatively) Simple</li>
	  </ul>
	</p>

	<h4>Source code</h4>
	<p>
	<pre><code>$ git clone https://github.com/isakkarlsson/bs</code></pre>
	</p>
	
	<h4>Installation</h4>
	<p>
	  Download the <em>bs.jar</em> file and;

	  <pre><code>$ java -jar bs.jar [file]</code></pre>

	  Alternatively can the source be downloaded and compiled
	  using Eclipse.
	</p>

	<h4>Running programs</h4>
	<p>
	  A program is a text file containing
	  some <em>bs</em>-code. There are no <code>main()</code>
	  methods or equivalent. Programs are evaluated from top to
	  bottom.
	  <pre><code>$ java -jar bs.jar Main.bs
John</code></pre>

	  Main.bs:
	  <pre><code>Person := Proto clone :Person.
p := Person clone.
p <- :name, "John".
System puts p -> :name.</code></pre>
	</p>

	<h4>Interactive mode</h4>
	<p>
	  Issue to enter interactive mode:
	  <pre><code>$ java -jar bs.jar</code></pre>

	  <pre><code> [1, 2] map { | x | x * 2. }.
[2, 4]</code></pre>
	  
	  All code, in the REPL, is invoked in the context
	  of <em>Module</em>.
	</p>

	<h3>Syntax</h3>

	<h4>Statements</h4>
	
	<p>There are two statements; assignment (<code>a := 1.</code>) and expressions.
	  <pre></code>program    ::= statements
statements ::= statement { statement }
statement  ::= assign | expression "."
assign     ::= identifier := expression </code></pre>
	</p>

	<h4>Expressions</h4> 
	<p>
	All else are expressions and everything in <em>bs</em> has a
	return value - even assignment, which return what is
	assigned. If a method does not explicitly return anything the
	receiver is returned. There are no keywords, only messages and
	assignments. The informal BNF (more formal but incomplete (and
	runnable) <a href="https://github.com/isakkarlsson/bs/blob/master/src/prolog/syntax.pl">here</a>):

	 <pre></code>expression ::= symbol | call
call       ::= symbol [message { message }]
call       ::= message { message } # with parentheses
message    ::= identifier [ expression ["," {expression}]]
message    ::= identifier "(" [ expression ["," {expression}]] ")"
symbol     ::= identifier | number | string | list | block
list       ::= "[" expression ["," { expression }] "]"
block      ::= "{" "|" [identifier ["," {identifier}]] "|" 
                   statement { statement } "}"</code></pre>
	</p>

        <h4>Messages</h4>
	<p>
	  Messages always have a receiver. If no receiver is explicitly
	  stated, the currently active object is used.
	</p>
	
	  <pre><code>System puts("Hello World").
load("Main.bs").</code></pre>
        <p>
	  The message <code>puts</code> is, thus in the example above,
	  invoked with <code>System</code> as receiver
	  and <code>load</code>, implicitly, with <code>Module</code> as
	  receiver. Parentheses can be omitted if the receiver is
	  explicitly stated. For example:
	</p>  
	  <pre><code>System puts "Hello" + " World".</code></pre>
        <p>
	  is equivalent to:
	</p>  
	  <pre><code>System puts("Hello" +(" World")).</code></pre>
        <p>
	  Noteworthy is the fact that <code>+</code> is just an other
	  message. Thus is operators implemented as messages and adhere
	  to the same rules. That is, they are executed from right to
	  left (starting with the arguments).
	  
	  For example:
        </p>
	  <pre><code>10 + 10.        # 20
10 +(10).       # 20
10 * 10 + 10.   # 200 i.e. 10 * (10 + 10) in C
10 *(10 +(10)). # 200 </code></pre>
        <p>
	  Messages can be forced to change precedence by using
	  <code>;</code> and parenthesis. For example:
        </p>
	  <pre></code>10 * 10; + 10.  # == (10 * 10) + 10 = 110
(10 * 10) + 10. # == (10 * 10) + 10 = 110
System puts 10 * 10; 10 + 10.
100
20</code></pre>

        <p>Valid names for identifiers are: any letter or symbol
        except: <code>| { } [ ] ( ) . , : ;</code></p>

	<pre><code>Account := Proto clone :Account.
Account <<= :init, {
  self <<- :balance. # create an instance field in self
}.
Account <<= :deposit, { | amount |
  return(balance + amount) # add the balance and amount
}.

a := Account clone.
a deposit 10.
System puts a -> :balance.</code></pre>

	<p>
	  Scopes are handled farily intuitively, a <em>message</em>
	  can only access arguments explicitly sent to it and the
	  reciver implicitly named <code>self</code>. The search are
	  conducted from the inner most nesting level outwards,
	  stopping at the message declaration. It is thus not possible
	  to get variables from outside a method (unless explicitly
	  sent). Further are variables already defined in an outer
	  scope <em>not</em> hidden by a new declaration. The value is
	  instead updated. This is to allow for, for example,
	  the <code>whileTrue</code> message.

	  Example:
	  <pre><code>outer := "Outer value".
<<=(:test, {
   System puts outer. # NameError
}).

n := 1.
{n < 10.} whileTrue {
   System puts n.
   n := n + 1. # Update the value
}.

</code></pre>
	</p>

	<h4>Operators</h4>

	<h3>Authors and Contributors</h3>
	
	<p>
	  Bs is written
	  by <a href="mailto:isak.karlsson@gmail.com">Isak
	  Karlsson</a>.
	</p>
	  	
	<h3>Support or Contact</h3>
	<p>Having trouble with bs? File a issue or
	  contact <a href="mailto:isak.karlsson@gmail.com">isak.karlsson@gmail.com</a>
	</p>
      </section>
    </div>
    
    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ?
      "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost +
      "google-analytics.com/ga.js'
      type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
      try {
      var pageTracker = _gat._getTracker("UA-31068540-1");
      pageTracker._trackPageview();
      } catch(err) {}
    </script>
    
  </body>
</html>
